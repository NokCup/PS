# 구현
***
구현이란 '머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정' 이다.어떤 문제를 풀든 간에 소스코드를 작성하는 과정은 필수이므로 구현 문제 유형은 모든 범위의 코딩 테스트 문제 
유형을 포함하는 개념이다.
<br>
우리는 알고리즘 문제를 해결할 때, 문제를 읽고 풀이 방법을 고민한다. 문제에 대한 풀이 방법이 떠오르면 프로그래밍 언어로 정확히 구현해냈을 때 비로소 정답 처리를 받을 수 있다.
이를 위해 프로그래밍 언어의 문법을 정확히 알고, 문제의 요구사항에 어긋나지 않는 답안 코드를 실수 없이 작성해야 한다.
<br><br>

구현 문제의 특징은 '풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어렵다' 는 점에 있다.
<br>
예를 들어 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제, 특정 소수점 자리까지 출력하는 문제, 문자열이 입력으로 주어졌을 때 한 문자 단위로 끊어서 리스트에  넣어야 하는
문제 등이 까다로운 구현 유형의 문제라고 할 수있다.

### 구현의 종류
***
이 책에서는 `완전 탐색` 과 `시뮬레이션` 유형을 모두 '구현' 유형으로 다루고 있다.
<br><Br>

- 완전 탐색 : 모든 경우의 수를 주저 없이 다 계산하는 해결 방법
- 시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행

<br><br>

### 구현 시 고려해야 할 메모리 사양
***
C/C++ 에서 int 자료형은 기본 4바이트이다. int 자료형 표현 범위는 -2,147,483,648~-2,147,483,647 인데 int 자료형으로 처리하면 이보다 큰 수를 처리할 수 없다는 의미가 된다.
8바이트dls `long long` 자료형을 쓰면 해결할 수 있지만, 이보다 큰 수는 처리할 수 없다.<br>
Java의 경우 Biginteger 표준 라이브러리를 지원하여 이보다 큰 수를 구현할 수 있지만, C++의 경우 표준 라이브러리에 포함되어 있지 않기 때문에 직접 BigInteger 클래스를 구현
하거니 이용해야 한다. 이 경우 인터넷을 이용해 외부 라이브러리 형태고 가져와 사용 할 수 있지만 이건 검색과 외부 라이브러리를 사용 가능한 코딩 테스트 환경일 때이다.<br>
(long long 보다 큰 정수를 처리하는 문제는 잘 출제되지 않는다.)
<br><br><Br>

파이썬의 장점은 직접 자료형을 지정할 필요가 없고 매우 큰 수의 연산 또한 기본으로 지원한다는 것이다.<br>
***다만 실수형 변수는 타 언어와 마찬가지로 유효숫자에 따라서 연산 결과가 원하는 값이 나오지 않을 수 있다는 것은 알아야 한다.***

<br><Br><Br>

### 파이썬 리스트 크기
***
<br>

|데이터의 개수(리스트 길이)|메모리 사용량|
|------|---|
|1,000|약 4KB|
|1,000,000|약 4MB|
|10,000,000,|약 40MB|

<br><Br><Br>

### 에제 4-1 [상하좌우]
***
풀이시간 14분 / 시간 제한 1초 / 메모리 제한 128MB
<br><br>

[내 코드]
```py
n = int(input())        #공간의 크기
x = 1
y = 1
arrows = input().split()

for arrow in arrows:
    if arrow == "R":
        if y == n:
            continue
        y +=1 
        print(x, y)
    elif arrow == "L":
        if y == 1:
            continue
        y -= 1
        print(x, y)
    elif arrow == "U":
        if x == 1:
            continue
        x -= 1
        print(x, y)
    elif arrow == "D":
        if x == n:
            continue
        x += 1
        print(x, y)

print(x, y)
```

[답안]
```py
n = int(input())
x, y = 1, 1
plans = input().split()

#L, R, U, D에 따른 이동 방향
dx = [0, 0, -1, 1]
dy = [-1, 1, 0 ,0]
move_types = ["L", "R", "U", "D"]


for plan in plans:          # R R R U D D
    for i in range(len(move_types)):
        if plan == move_types[i]:
            nx = x + dx[i]
            ny = y + dy[i]
            print(nx, ny)
    if nx < 1 or ny < 1 or nx > n or ny > n:        
        continue                                # U를 입력했을 때 위치가 업데이트 되지 않는다.
        
    x, y = nx, ny
```

### 예제 4-2 시각
***
풀이 시간 15분/ 시간 제한 2호/ 메모리 제한 128MB

<br>

#### 문제 해석
24시간 = 86,400초 이므로 하나씩 모두 세어도 충분히 제 시간 내에 풀 수 있는 문제다.<br>
3중 반복문을 이용해 풀어보자.

[답안]
```py
h = int(input))
count = 0

for i in range(h + 1):
    for j in range(60):
        for k in range(60):
            if '3' in str(i) + str(j) + str(k):
                count += 1
print(count)
```





  
