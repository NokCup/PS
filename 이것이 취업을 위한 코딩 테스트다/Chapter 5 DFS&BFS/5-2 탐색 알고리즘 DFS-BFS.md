# DFS
DFS(Depth-First Search) 는 ***'깊이 우선 탐색' 이라고 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘***이다.
<br><br>

DFS를 이해하려면 그래프의 기본 구조를 알아야 한다.
<br><br>

![화면 캡처 2024-09-12 195212](https://github.com/user-attachments/assets/c20503f3-dec6-4204-bd1c-3896f5a72dc8)

<br>
그래프는 노드(Node) 와 Edge(간선) 으로 구성된다. 노드를 정점(Vertex) 이라고도 부른다. <br>두 노드가 간선으로 연결되어 있다면 '두 노드는 인접하다' 라고 표현한다
<br><br>

프로그래밍에서 그래프를 2가지 방식으로 표현한다.

- 인접 행렬(Adjacency Matirx) : 2차원 배열로 그래프 연결 관계를 표현하는 방식

- 인접 리스트(Adjacency List) : 리스트로 그래프 연결 관계를 표현하는 방식

<br> <br>

## 인접 행렬

<img width="1500" alt="image" src="https://github.com/user-attachments/assets/494ba9fe-f6d3-40aa-9111-0a33c0d17fd1">

<br>

위 그래프처럼 인접 행렬은 2차원 배열에 각 노드가 연결된 형태를 기록한다.<br>
연결 되어 있지 않은 노드끼리는 '무한의 비용' 이라고 작성한다.

<br><br>

코드에서는 무한의 비용을 논리적으로 정답이 될 수 없는 큰 값 중에서 999999999, 98765432 등의 값으로 초기화하는 경우가 많다.

```py
INF = 999999999     #무한의 비용 선언

# 2차원 리스트를 이용해 인접 행렬 표현
graph = [
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0]
]

print(graph)
```
>[실행결과]<br>
[[0, 7, 5], [7, 0, 999999999], [5, 999999999, 0]]

<br><br>

## 인접 리스트
인접 리스트 방식은 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장한다.

<br>

<img width="600" alt="image (1)" src="https://github.com/user-attachments/assets/c3a01e2b-c222-4b3f-89da-8e8b6ba86c3e">

<br>

C++, JAVA 의 경우에는 연결 리스트 기능을 위한 표준 라이브러리를 제공한다.<br>
Python은 기본 자료형인 리스트 자료형이 append() 메소드를 제공한다. 즉 배열과 연결 리스트의 기능을 모두 기본으로 제공한다. 따라서 인접 리스트를 이용해 그래프를 그린다면 단순히 2차원 리스트를 이용하면 된다.

<br><Br>

```py
# 행이 3개인 2차원 리스트로 인접 리스트 표현
graph = [[] for _ in range(3)]


# 노드 0에 연결된 노드 정보 저장(노드, 거리)
graph[0].append((1, 7))
graph[0].append((2, 5))


# 노드 1에 연결된 노드 정보 저장(노드, 거리)
graph[1].append((0, 7))


#노드 2 에 연결된 노드 정보 저장(노드, 거리)
graph[2].append((0, 5))

print(graph)
```
> [실행결과]<br>
> [ [ ( 1 , 7 ) , ( 2 , 5 ) ], [ ( 0 , 7 ) ] , [ ( 0 , 5 ) ] ]


## 인접 행렬과 인접 리스트의 차이
두 방식은 메모리와 속도 측면에서 보았을 때 다음의 차이가 있다.

- 인접 행렬 방식은 속도가 빠르다
  
- 인접 리스트는 메모리를 효율적으로 사용한다.

<Br><br>

인접 행렬 방식은 모든 관계를 저장한다. 따라서 노드 개수가 많을수록 메모리가 불필요하게 낭비된다.<br> 인접 리스트 방식은 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용한다.

<br>

이와 같은 속성 때문에 인접 리스트 방식은 연결된 데이터를 하나 하나 확인해야 해서 속도가 느리다. 

## DFS 그래프
DFS는 스택 자료구조를 이용하며 동작 구조는 다음과 같다.

1. 탐색 시작 노드를 스택에 삽입하고 방문 처리

2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고 방문 처리를 한다.<br>
방문하지 않은 인접 노드가 없다면 최상단 노드를 꺼낸다.

3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다.


<br>

- '방문 처리' 는 스택에 다시 삽입하지 않게 체크하는 것을 의미

- 코딩 테스트에서는 노드의 번호가 낮은 순서부터 처리하도록 명시하는 경우가 종종 있다. 따라서 관행적으로 ***번호가 낮은 순서부터 처리하도록 구현*** 하는 편이다.


<br><br>

![스크린샷 2024-09-12 211534](https://github.com/user-attachments/assets/2f1c7ed5-6c6f-4ae8-a8ab-b0f5436766e3)

<br><br>

```py
# DFS 메서드 정의
def dfs(graph, v, visited):
    #현재 노드를 방문 처리
    visited[v] = True
    print(v, end=' ')

    #현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)



# 각 노드가 연결된 정보를 2차원 리스트로 표현
graph = [
    [],
    [2, 3, 8],       # 노드 1
    [1, 7],          # 노드 2
    [1, 4, 5],       # 노드 3
    [3, 5],          #  .
    [3, 4],          #  .   
    [7],             #  .
    [2, 6, 8],
    [1, 7]           # 노드 8
]


# 각 노드가 방문된 정보를 1차원 리스트로 표현
visited = [False] * 9 


# 정의된 DFS 함수 호출
dfs(graph, 1, visited)
```
> [실행결과]<br>
1 2 7 6 8 3 4 5

<br><br>

# BFS
BFS(Breadth First Search) 는 '너비 우선 탐색' 이라는 의미한다. <br>
***'가까운 노드부터 탐색'*** 하는 알고리즘이다.
 <Br><br>


BFS 구현에서는 큐 자료구조를 이용하는 것이 정석이다. 
<br>
동작 방식은 다음과 같다.

1. 탐색 시작 노드를 큐에 삽입하고 방문 처리
   
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리
   
3. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복
   

  <br>

![스크린샷 2024-09-12 211534](https://github.com/user-attachments/assets/2f1c7ed5-6c6f-4ae8-a8ab-b0f5436766e3)


<br><br>

```py
from collections import deque


#BFS 메서드 정의
def bfs(graph, start, visited):
    #큐 구현을 위해 deque 라이브러리 사용
    queue = deque([start])
    
    #현재 노드를 방문 처리
    visited[start] = True

    # 큐가 빌 때까지 반복
    while queue:
        #큐에서 하나의 원소를 뽑아 출력
        v = queue.popleft()
        print(v, end=' ')

        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True

# 그래프
graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7]
]

# 방문 처리
visited = [False] * 9

# bfs함수 호출
bfs(graph, 1, visited)

```
>[실행 결과]<br>
1 2 3 8 7 4 5 6


