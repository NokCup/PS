# 큰 수의 법칙


### 시간 제한

1초

### 메모리 제한

128MB

### 분류

그리디 알고리즘


***
### 문제 설명

<p>'큰 수의 법칙'은 일반적으로 통계 분야에서 다루어지는 내용이지만 동빈이는 본인만의 방식으로 다르게 사용하고 있다. 동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 방법이다. 단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.

예를 들어 순서대로 2, 4, 5, 4, 6으로 이루어진 배열이 있을 때, M이 8이고 K가 3이라고 가정하자.
이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5인 46이 된다.

 단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.
예를 들어 순서대로 3, 4, 3, 4, 3으로 이루어진 배열이 있을 때 M이 7이고 K가 2라고 가정하자. 이 경우 두 번째 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두 번씩 더하는 것이 가능하다.
결과적으로 4 + 4 + 4 + 4 + 4 + 4 + 4 인 28이 도출된다.

배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오.</p>


<br>

### 입력 
- 첫째 줄에 N(2 <= N <= 1000), M(1 <= M <= 10000), K(1 <= K <= 10000)의 자연수가 주어지며 각 자연수는 공백으로 구분한다.

- 둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1 이상 10000 이하의 수로 주어진다.

- 입력으로 주어지는 K는 항상 M보다 작거나 같다.

### 출력 

- 첫째 줄에 동빈이의 큰수의 법칙에 따라 더해진 답을 출력한다.
<br><br>

### 입력 예시 
> 5 8 3<br>
> 2 4 5 4 6
### 출력 예시
> 46

<br><br>

***

### 문제 해석

[2, 4, 5, 4, 6] 으로 이루어진 배열에서 M = 8, K = 3 이라 하자. <br>
M은 주어진 수들을 M번 더한다는 것이고, K는 특정 인덱스의 수를 3번 연속 쓸 수 있다는 것이다.<br>

가장 큰 수를 구한다고 했을 때 다음과 같이 구할 수 있다.

> [6 + 6 + 6 + 5 + 6 + 6 + 6 + 5] = 46

가장 큰 수를 k번 반복했고, 두번째로 큰 수가 한번 나온 후 바로 가장 큰 수를 다시 반복한다. 즉 우리가 구해야 하는 수는 ***'가장 큰 수와 두번째로 큰 수'*** 이고<br>
***'가장 큰 수를 K번 더하고 두번째로 큰 수를 한 번 더하는 연산의 반복'*** 하도록 코드를 짜면 된다.
<br><br><br>


```py
n, m, k = map(int, input().split())         # n, m, k 입력 
data = list(map(int, input().split()))      # 배열 입력

data.sort()                                 #배열 오름차순  정렬

first = data[n - 1]                         # 가장 큰 수
second = data[n - 2]                        # 두번째로 큰 수
result = 0                                  # 결과

while True:                 
    for i in range(k):
        if m == 0:
            break
        result += first                     # result 에 최댓값 더하기
        m -= 1
    if m == 0:
        break
    result += second                        # result 에 두번째로 큰 수 더하기
    m -= 1

print(result)                               #최종 답안 출력
```

<br><br><br>

***

### 수학적 아이디어를 이용한 문제 해석
이 문제는 M의 크기가 10,000 이하이므로 위 코드처럼 해결할 수 있지만, 만일 M의 크기가 100억 이상 커지면 시간 초과 판정을 받게된다. 간단한 수학적 아이디어를 이용해 효율적으로 문제를 해결해보자.
<br><br>

[2, 4, 6, 5, 8] 의 배열에서 M = 8, K = 3 이라 가정해보자. <br>

> 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5

위를 보면 (6 + 6 + 6 + 5) 로 반복되는 것을 알 수 있다.<br>
이 반복되는 수열을 이용해서 수학식을 작성해보자.
<Br><Br>

> 반복되는 수열의 길이 = K + 1 (6 3개, 5 1개) <br>
> 
> M // (K + 1) : 수열의 반복 횟수 <br>
>
> { M // (K + 1) } * k : 가장 큰 수의 반복 횟수

<br>

M // (K + 1) 로 나누어 떨어지지 않는 경우도 고려해보자. <br>
> M % (K + 1) : 가장 큰 수의 나머지 개수

<br><br>

### ***int((m // (k+1)) * k + m % (k+1) )*** <br>

결과적으로 위 식(가장 큰 수의 등장 횟수) 을 이용해서 문제를 해결할 수 있다. 

<br><br>

```py
n, m, k = map(int, input().split())

data = list(map(int, input().split()))

# 가장 큰 수를 K번 더하고 2번째 큰수 1번 더하기 그러려먼 큰 수 작은 수 구해야 함.

data.sort()

first = data[n - 1]
second = data[n - 2]

count = (m // (k + 1)) * k
count += m % (k + 1)                     # 가장 큰 수의 등장 횟수

result = 0
result = count * first                   # 가장 큰 수 더하기
result = (m - count) * second            # 전체 개수 - 가장 큰 수의 개수 = 두번째로 큰 수의 개수
```


