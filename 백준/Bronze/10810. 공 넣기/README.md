# [Bronze III] 공 넣기 - 10810 

[문제 링크](https://www.acmicpc.net/problem/10810) 

### 성능 요약

메모리: 31120 KB, 시간: 36 ms

### 분류

구현, 시뮬레이션

### 제출 일자

2024년 9월 1일 11:27:26

### 문제 설명

<p>도현이는 바구니를 총 N개 가지고 있고, 각각의 바구니에는 1번부터 N번까지 번호가 매겨져 있다. 또, 1번부터 N번까지 번호가 적혀있는 공을 매우 많이 가지고 있다. 가장 처음 바구니에는 공이 들어있지 않으며, 바구니에는 공을 1개만 넣을 수 있다.</p>

<p>도현이는 앞으로 M번 공을 넣으려고 한다. 도현이는 한 번 공을 넣을 때, 공을 넣을 바구니 범위를 정하고, 정한 바구니에 모두 같은 번호가 적혀있는 공을 넣는다. 만약, 바구니에 공이 이미 있는 경우에는 들어있는 공을 빼고, 새로 공을 넣는다. 공을 넣을 바구니는 연속되어 있어야 한다.</p>

<p>공을 어떻게 넣을지가 주어졌을 때, M번 공을 넣은 이후에 각 바구니에 어떤 공이 들어 있는지 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 N (1 ≤ N ≤ 100)과 M (1 ≤ M ≤ 100)이 주어진다.</p>

<p>둘째 줄부터 M개의 줄에 걸쳐서 공을 넣는 방법이 주어진다. 각 방법은 세 정수 i j k로 이루어져 있으며, i번 바구니부터 j번 바구니까지에 k번 번호가 적혀져 있는 공을 넣는다는 뜻이다. 예를 들어, 2 5 6은 2번 바구니부터 5번 바구니까지에 6번 공을 넣는다는 뜻이다. (1 ≤ i ≤ j ≤ N, 1 ≤ k ≤ N)</p>

<p>도현이는 입력으로 주어진 순서대로 공을 넣는다.</p>

### 출력 

 <p>1번 바구니부터 N번 바구니에 들어있는 공의 번호를 공백으로 구분해 출력한다. 공이 들어있지 않은 바구니는 0을 출력한다.</p>

***

### 문제 분석
N = 바구니 개수, M = 반복 횟수를 의미한다. 

N = 5,  M = 4 라 가정했을 때, 바구니는 [0 0 0 0 0] 총 5개, 공을 넣는 것을 4번 반복한다는 것이다.
<br><br>
i, j, k 는 각각 시작, 끝, 넣을 공 번호를 의미한다.

1 2 3 이라 하면 1번부터 2번까지 공 3을 넣는다는 것. [3 3 0 0 0] 을 의미한다. 코드를 짜보면
<br><br><br>

```py
n, m = map(int, input().split())        # N = 바구니 개수 M = 반복 횟수
array = [0] * n                         # N개의 0으로 리스트 초기화 [0, 0, 0, 0, 0]

for _ in range(m):
    i, j, k = map(int, input().split())     #i = 시작, j = 끝, k = 넣을 공의 번호
```
이런식으로 짤 수 있다.
<br><br>
여기서 나는 array = [0, 0, 0, 0, 0] 에서 <br>
1, 2, 3 을 입력했을 때 1부터 2번까지 순서대로 3을 입력하는 코드를 짜기 위해 반복문을 이용했다. [3, 3, 0, 0, 0] 을 만들기 위해서는 인덱스로 0과 1에 3을 넣어야한다.


```py
for x in range(j - i + 1):          # (1 ~ 2) : 3번 반복     => for x in range(2 - 1 + 1)           => for x in range(j - i + 1) = for x in range(j - (i - 1))
    array[i + x - 1]                         # 인덱스 0 과 1

print(*array)                     
```

<br><br><br>

***
# 숏코딩 분석

```py
for x in range(j - i + 1):      
    array[i + x - 1]                        
```
<br>

위 코드를

<br>

```py
array[i - 1 : j] = [k] * (j-i+1)
```

이렇게 줄일 수 있다.
1, 2, 3 을 입력했을 때 array에 1부터 2까지 k 를 2번 넣는다.
<br><br>

여기서 왜 k가 아니라 [k] 로 작성한건지 궁금해서 찾아보았다.
 <br><br><br>

 # 인덱싱 & 슬라이싱
- 리스트에 접근할 때 리스트 접근, 슬라이싱 접근에는 차이가 있다.
<br><br>

예를 들어 

```
a = [1, 2, 3, 4]
k = 5
a[3] = k
print(a)
```
> [1, 2, 3, 4, 5]

이렇게 리스트의 4번째 인덱스에 접근할 때 정상적으로 실행된다.
<br>

```
a = [1, 2, 3, 4]
k = 5
a[3:] = k
print(a)
```
> TypeError: can only assign an iterable

슬라이싱으로 리스트 접근 시 TypeError가 생긴다.

<br>

```
a = [1, 2, 3, 4]
k = 5
a[3:] = [k]
print(a)
```
[1, 2, 3, 5]

k를 [k] 로 바꿔주니 정상적으로 실행된다.

따라서 슬라이싱으로 리스트 요소에 접근할 때에는 반드시 수정할 요소를 리스트로 만들어 줘야 한다.
